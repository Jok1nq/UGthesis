\cleardoublepage
\section{自动化根因分析相关技术研究}        %第2章
\subsection{概述}
在科学和工程学中，根因分析是一种解决问题的方法，用于识别故障或问题的根本原因。
它广泛应用于IT运营、电信、工业过程控制、事故分析、医学等。
根因分析通常是一种系统性的过程，需要收集和分析与问题相关的数据和信息，运用各种工具和技术来确定问题的根本原因。
在计算机领域，特别是在软件安全领域，根因分析通常是指分析软件或系统崩溃的根本原因，它可能涉及对系统的代码、设计、配置、环境等方面进行深入分析。
~\autoref{fig:RCA}是计算机领域根因分析方法概述，通过根因分析，开发团队可以更好地了解程序中的潜在问题，并及时采取措施修复和加固系统，以提高软件的安全性和稳定性。
根因分析通常需要与模糊测试方法结合使用，作为一种粗略的可靠性度量方法，模糊测试可以针对待分析程序产生不同输入得到程序崩溃，并提示程序哪些部件需要特殊的注意；
而根因分析作为模糊模糊测试的后续阶段，可以利用，模糊测试得到的已知崩溃进行深入分析并找出导致这些问题的根本原因。
\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{./figure/RCA.png}
    \caption{计算机领域根因分析概述}
    \label{fig:RCA}
\end{figure}

一般来说，当前自动化根因分析方法主要包括两类:基于频谱的根因分析方法和基于事后的根因分析方法。
其中基于频谱的方法通常在初始崩溃测试用例的基础上生成两大组崩溃测试用例和非崩溃测试用例。
它们记录每条指令上的寄存器和内存数据，以统计方式构建崩溃的必要条件作为谓词，测量每个谓词与初始崩溃的相关性，最后将谓词列为根本原因；
而基于事后的故障定位方法从调试文件(例如核心转储和内存快照)开始，执行反向执行和向后污染分析，以跟踪无效数据的传播。
它们分析指令的语义，比基于频谱的故障定位方法更有效。
同时，随着当前AI领域的发展，机器学习的长足发展与大模型的出现使根因分析进入了新的维度，一些繁杂的人工工作可以交由AI辅助进行。
这极大提高了一些受到时间和复杂程度限制方法的效率，拓宽了根因分析领域。

下面将从这三个方面介绍自动化根因分析相关技术的研究。
\subsection{自动化根因分析相关方法}
\subsubsection{基于频谱的自动化根因分析方法}
基于频谱的分析方法是一种利用软件系统的执行频谱（Execution Spectrum）来识别和定位问题的技术。
该方法通常用于识别性能问题和资源利用不足等情况。
基本原理是在软件运行时记录系统的执行轨迹或事件，然后通过分析这些事件的频率和模式来识别可能的瓶颈或问题。
基于频谱的故障定位技术基于一个核心假设：程序中出错频率较高的部分更有可能是故障所在。
这种方法使用“频谱”信息，即程序执行过程中各个组件（如函数、语句或分支）的执行频率和失败频率的统计数据。
例如，对于性能问题，可以记录系统中的函数调用、代码路径执行次数、资源利用情况等信息。
通过分析这些数据，可以确定哪些函数或路径是性能瓶颈，并识别可能的优化方向。
\autoref{fig:Benzene}是一种基于频谱的自动化根因分析方法~\cite{BENZENE}。
\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{./figure/Benzene.png}
    \caption{一种基于频谱的自动化根因分析方法}
    \label{fig:Benzene}
\end{figure}


基于频谱的分析方法可以帮助开发人员了解系统的执行特征，并优化系统的性能和资源利用率。
大多数基于频谱的根因分析技术研究侧重于统计量的设计，
通过分析数据的分布特性来识别潜在的根因，并对对可能的根因进行排序的规则进行特别的设计。
但也有一些工作侧重对测试用例的研究：
Hao等人~\cite{Test2010}根据测试用例的能力提出了三种减少测试用例数量的策略，基于使用测试输入的测试运行的执行跟踪，使开发人员可以只选择测试输入的一个有代表性的子集来进行结果检查和故障定位；
Abreu等人~\cite{practical2009}通过使用由西门子集和空间程序组成的通用基准，研究了作为多个参数（例如系统执行期间收集的程序频谱的质量和数量）的函数的诊断准确性，结果表明用于分析程序谱的特定相似系数的优越性能在很大程度上独立于测试设计，并且证明了基于频谱的分析方法可以有效地应用于工业环境中的嵌入式软件开发环境中；
Dandan Xu等人~\cite{Racing}设计并实现了一种反例强化学习技术，该技术奖励涉及反例的操作，通过平衡随机抽样和对反例的利用，利用每个模糊测试回合的结果来指导下一轮模糊测试，从而将当今基于频谱的根因分析工具的可扩展性和准确性提高了一个数量级以上。

\subsubsection{基于事后的故障定位方法}
基于事后的根因分析技术是一种在崩溃发生后开始的根因分析技术。
该方法的基本原理是通过收集和分析系统状态、日志、内存转储等信息，来确定问题的根本原因和触发条件。
通过分析这些信息，可以确定程序的内存泄漏、空指针引用等异常行为，并采取措施修复或预防类似问题的再次发生。
在事后程序分析技术中，记录与重放~\cite{ReCrash2008}~\cite{SymCrash2014}~\cite{Chronicler2013}和核心转储分析~\cite{RETracer2016}~\cite{Making2015}~\cite{CREDAL2016}是两种常见方法。
\autoref{fig:symcon}是一种基于事后的故障定位方法~\cite{SymCrash2014}。
\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{./figure/Symcon.png}
    \caption{一种基于事后故障定位根因分析方法}
    \label{fig:symcon}
\end{figure}


\textbf{记录与重放。}\ 这种方法的核心思想是在程序运行时使用工具捕获程序的执行轨迹和状态，从而允许开发者在出现故障时能够准确重现问题。
在程序执行过程中，记录所有导致状态变化的事件，包括函数调用、外部输入、线程操作和其他系统调用等事件。
之后利用捕获的这些事件的参数和结果，以及它们的时间戳和执行顺序进行事后分析，找到导致崩溃的根因。
值得注意的是通常“记录”过程需要通过修改操作系统的内核、使用特定的库或工具、或者插桩代码来实现；同时“重放”过程通常需要在一个控制的环境中进行，以避免非确定性行为的干扰。
这种方法存在着局限性：（1）记录阶段可能会引入显著的时间和空间开销，特别是在需要详尽记录的情况下。
（2）无法重放某些不确定性较高的行为：如并发和竞争条件漏洞导致的崩溃就可能在重放时难以精确复现。

\textbf{核心转储分析。}\ 与记录与重放方法不同，核心转储分析方法涉及捕捉程序崩溃时的内存镜像，以便分析和诊断导致崩溃的原因。
这种技术对于理解复杂软件系统的失败原因非常有用，特别是在调试难以复现的故障时体现出了较大的优势。
核心转储方法的基本原理是当程序异常终止（如段错误）发生崩溃时，自动保存那部分程序执行时的内存内容。
这个转储文件包含了程序终止时的变量值、程序计数器、寄存器内容、堆栈信息等关键数据。
发生崩溃后，分析者通过检查崩溃时的内存状态，分析崩溃的上下文，确定崩溃发生在程序的哪一部分。
这种方法存在着一定的局限性：（1）核心转储文件可能非常大，尤其是密集应用内存的程序，这可能极大提高分析的开销。
（2）某些崩溃依赖于程序运行的特定环境或状态，单纯利用核心转储文件无法分析导致崩溃的原因。


虽然当前这些研究被证明是有效的，但它们只关注特定的类型状态问题，或者在反向执行时难以解决内存别名等问题，仍然不足够高效。
\subsubsection{基于模型的自动化根因分析方法}
这种方法利用机器学习算法来自动识别和诊断系统故障的根本原因，并依赖于历史数据和模式识别技术来预测和识别问题的根源。这种方法在处理复杂系统和大规模数据时显示出其独特的优势。
通过分析系统的正常运行数据和故障时的数据，机器学习模型可以学习到哪些指标或事件与系统故障强相关。
在基于机器学习的自动化根因分析方法中，首先收集系统的运行日志、性能指标、系统事件等数据；
其次从原始数据中提取有用的特征如CPU使用率、内存使用量、响应时间、错误率等，这些特征能够代表系统的运行状态或可能影响系统性能和稳定性的因素；
之后利用其训练机器学习模型，并在实际数据上运行模型，以检测和预测潜在的系统故障。
\autoref{fig:LLM}是一种基于模型的故障定位方法~\cite{How2024}。
\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{./figure/LLM.png}
    \caption{一种基于模型的根因分析方法}
    \label{fig:LLM}
\end{figure}

值得注意的是，这种方法也存在着一定的局限性：（1）模型的效果很大程度上依赖于高质量和高覆盖率的数据，需要人工提供较为优质的训练数据。（2）模型需要不断维护、微调与更新，从而能在快速变化的系统环境中适应新的数据和条件。


\subsection{其他相关研究}
\subsubsection{逆向执行}
在基于事后分析的故障定位领域，分析人员通过反向执行来更深入地了解程序崩溃~\cite{RETracer2016}~\cite{REPT}。
反向执行是一种通过撤销已执行的指令，恢复寄存器和内存值到先前状态的技术，使分析人员能够从独特的视角观察程序状态随时间的演变过程。
这需要分析人员设计复杂的处理器，根据指令的行为逆向执行指令。
在本文关注的嵌入式固件领域，目标硬件平台的资源受限性质通常严重限制了监控和记录能力，导致无法获取足够的数据以支持全面的反向执行。
为了解决这一问题，需要设计合理的运行时记录方法，并为嵌入式固件设计合适的逆向处理器。

\subsubsection{使用-定义链}
在数据流分析领域，使用-定义链(Use-Define Chain)是一种描述程序中一个变量的使用和所有定义的数据结构，该变量可以在没有任何其他中间定义的情况下到达使用~\cite{Compilers2007}。
使用定义链建立了程序中变量的定义点（定义变量值的地方）与使用点（使用这些变量值的地方）之间的关系。
通过这种结构，分析人员可以追踪变量值是如何在程序中传递和转换的，从而可以提高逆向执行中的效率。

\subsection{本章小结}
本章中，首先对根因分析方法进行了简单背景介绍，然后讨论了当前主流的几种自动化根因分析方法，并分析了他们的优势与不足。
最后补充分析了自动化根因分析方法中逆向执行和使用-定义链等其他相关研究。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%第3章 物联网嵌入式固件自动化根因分析%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\section{物联网嵌入式固件自动化根因分析}    %第3章
\subsection{引言}                         %3.1节
随着网络技术的飞速发展，物联网技术的应用已经渗透到各个产业领域。
嵌入式固件在这些领域中起着关键作用，它使得设备和系统能够实现自动化、智能化的控制和管理，提高生产效率、节约资源、降低成本。
然而随着嵌入式固件深入生活各个领域，其中的漏洞与安全问题重要性愈发重要。
2023年12月，丰田雷克萨斯~\cite{toyota}由于发动机电子控制单元存在安全隐患，召回了超过十万辆车。
嵌入式固件安全在国防方面同样重要，俄乌战争中，Viasat的KA-SAT网络受到了攻击~\cite{KASAT}，
攻击者利用卫星调制解调器固件的漏洞进行攻击，导致KA-SAT的卫星宽带服务部分中断，影响了数千名客户和5800台风力涡轮机的远程访问。

目前模糊测试领域已有较为成熟的方法来检测固件漏洞，但在模糊测试发生崩溃后，需要进一步进行根因分析导致崩溃的原因，修复漏洞。
目前已有基于频谱分析、基于事后分析以及基于模型分析等几种主流的自动化根因分析方法，
但目前尚未有针对嵌入式固件的自动化根因分析方法。由于嵌入式固件运行时资源受限，以及代码缺乏必要的调试信息，导致在固件领域已有的自动化分根因析方法难以有效分析导致崩溃的根本原因；
而手动分析较为繁琐，且由于人工难以理解二进制固件代码，难以全面分析，并高覆盖率发现bug。

综上所述，如何针对物联网嵌入式固件实现高效自动化根因分析方法，发现固件漏洞，保障物联网嵌入固件安全，是当前亟需解决的问题。

\subsection{本文研究的问题定义}             %3.2节
\subsubsection{本文关注的根本原因}          %3.2.1节
现实世界中的固件崩溃原因多种多样且复杂，如使用后释放（use after free）、双重释放（double free）和越界写入（out-of-bounds write）。
然而，大多数固件崩溃的原因是两个：无效的内存访问和无效的指令执行。
因为它们直接关系到程序的基本执行和内存管理机制，尤为重要，是所有计算系统都必须妥善处理的基本安全和稳定性挑战，解决这类漏洞是提高固件质量和系统安全的关键。
本文选取这两个漏洞进行重点分析，将导致固件崩溃的根因定义为这两种漏洞。

\textbf{无效的内存访问。}\ 无效的内存访问是指程序试图访问其没有权限访问的内存区域，主要包括以下几种：
（1）越界访问：程序试图访问数组、字符串或其他数据结构的边界之外的内存；
（2）野指针访问：未初始化或已释放的指针被错误地用于内存访问；
（3）空指针解引用：程序试图通过一个指向NULL的指针访问内存或访问已经被释放的内存块。
这些无效内存访问会触发操作系统的保护机制，如分页错误（page fault）或访问违规（access violation），从而导致程序崩溃或终止。
同时也可能导致数据损坏或被恶意代码利用。

\textbf{无效的指令执行。}\ 无效的指令执行通常指的是程序试图执行非法或非预期的机器指令。通常由以下情况几种引起：
（1）代码损坏：程序代码由于某种原因（如内存损坏、磁盘故障、恶意攻击等）被更改，导致执行流程跳转到非法的指令上；
（2）函数指针错误：错误的函数指针可能导致程序跳转到错误的地址执行，尤其是在使用动态链接库（DLL）或回调函数时；
（3）类型错误：程序错误解析了变量类型，或应用了不匹配的类型，如将整数用作函数指针，可能导致程序尝试执行数据区域的代码。
执行无效指令可能导致程序行为不可预测，从错误操作到程序崩溃都可能发生，严重时可能被用于执行恶意代码，是一种较为常见但是又较为危险的漏洞。

\subsubsection{内存别名问题}                %3.2.2节
在分析固件崩溃的原因时，分析人员需要通过逆向分析执行轨迹，通过逆向导致崩溃过程的指令，来分析出导致崩溃的根本原因。
这一过程涉及对崩溃前的数万条指令的深入分析，以追踪数据的流向和变化。
在分析导致固件崩溃的执行轨迹时，需要重点考虑故障定位中的一个常见而关键的问题——内存别名问题。
该问题描述的是多个指针可能指向同一块底层内存位置，在逆向时无法确定是哪个指针导致了内存的改变。
这种情况增加了数据流分析的不确定性，并且复杂化了准确追踪数据传播的任务~\cite{REPT}~\cite{RETracer2016}。

\begin{lstlisting}[%
    language={asm},
    caption={内存别名问题示例},
    label={code_alias}
]
; 假设edi寄存器存储的是某个对象的地址
mov eax, [edi + 4]  ; 从对象中加载第一个字段到 eax
add eax, 10         ; 对该字段增加10
mov [edi + 4], eax  ; 将修改后的值写回相同位置

; esi寄存器通过计算得到相同的内存地址
lea esi, [edi + 4]  ; 加载相同的内存地址到 esi
mov ebx, [esi]      ; 加载数据到 ebx，期望得到原始数据
\end{lstlisting}

具体地，\autoref{code_alias}是一个内存别名的简单例子，在这个例子中，$edi+4$和$esi$实际上指向同一内存位置，$eax$通过$edi + 4$加载和存储数据，而$ebx$通过$esi$来加载数据。
虽然$edi+4$和$esi$指向同一地址，但途径不同，这会使逆向工程师或者自动化工具误为这两个操作影响的是两个独立的内存区域；
也会导致我们无法分析出内存的改变是哪个指针做出的，这对代码分析影响极为严重，甚至可能导致巨大的性能下降。
此外，在并发编程中，内存别名会增加数据竞态的风险。

因此，内存别名作为一项重要的问题，需要在自动化方法设计中特备关注。

\subsection{物联网嵌入式固件自动化根因分析方法设计} %3.3节
针对嵌入式固件运行时资源有限以及调试信息有限的特点，我们提出了如~\autoref{fig:overview}所示的自动化根因分析框架。
\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{./figure/Overview.png}
    \caption{物联网嵌入式固件自动化根因分析方法框架}
    \label{fig:overview}
\end{figure}\\

本方法通过三个主要组件实现高效精准的崩溃分析：
首先是高效运行时信息记录组件，在此阶段，系统通过模拟执行引起崩溃的测试用例来收集关键的运行时数据；
之后是历史信息指导的逆向执行组件，此阶段利用记录的数据解决内存别名问题，确保数据流分析的准确性；
最后进行根因分析组件，通过后向污点分析确定导致崩溃的具体原因，为进一步的调查提供指导。
这一整体架构能够在资源受限的环境中有效地定位固件中的错误和安全漏洞。

\subsubsection{高效运行时信息记录}
为了有效地分析固件崩溃，解决在资源受限的固件环境中调试机制不足的问题，本设计引入了一种高效的运行时信息记录的方法。
本方法首先执行带有崩溃测试用例的固件二进制文件，并收集运行时数据，如寄存器状态和内存访问等，以支持随后的反向执行和根本原因分析。

为了分析固件崩溃，本方法主要识别了一种关键的事件类型：内存读取与写入。
这些事件涉及到内存的读取和写入操作，如内存访问，寄存器操作等。
内存读写事件在后续追踪中，可以有效辅助分析崩溃过程中数据是如何被处理和转移的。
系统利用固件重置技术来执行崩溃测试用例，同时监控和记录内存读写。
\begin{lstlisting}[
    language={asm},
    caption={内存读取与写入事件示例},
    label={code_memacc}
]
0x403b76 STR R0, [R3, #16]      ;(a)R0:0x0, R3:0x201073c4
0x403b78 LDR R9, [R5, #16]
…
0x406c78 LDR R6, [R0, #16]      ;(b)R0:0x201073c4, R6:0x0
0x406c7a LDR R4, [R6, #8]       ;(c)Crash!
\end{lstlisting}

如~\autoref{code_memacc}所示， 程序首先在地址$R3 + 16$处存储$R0$的值（指令a）；
然后程序加载$R0 + 16$地址处的值并将其赋给$R6$（指令b），由于此处$R0$值与指令$a$处$R3$值相同，所以$R6$的值会变为$0x0$；
接着，程序试图从$R6 + 8$的地址加载值，由于$R6$此时为$0x0$，导致了空指针解引用的崩溃（指令c）。

这个例子展示了一个无效读取导致的崩溃。然而，在给定崩溃测试用例和固件二进制文件的情况下，获取此类崩溃知识并不是一件简单的事情。
分析人员需要深入研究运行时细节，检查从崩溃现场开始的每一条指令，最终确定$R0 + 16$和$R3 + 16$指向相同地址（即$0x201073d4$），
并且$R0$在指令a处被赋予的无效值（即$0x0$）引发了崩溃。

为了解决这种问题对根因分析造成的困扰，我们设计了一种高效的运行时信息记录方法。
首先我们在仿真环境模拟运行程序，在运行时主要关注两种类型的内存事件：（1）成功的内存读取和（2）成功的内存写入。
当任何一种事件发生时，本方法会暂停仿真，捕捉相关的运行时信息，如指令地址、操作的数据、寄存器状态以及内存地址等。
为了有效地保存和追踪这些事件，我们设计了一种特定的数据结构，用以记录内存访问的类型（读或写）、执行的指令地址、具体的数据内容、相应的内存地址以及寄存器的值。
%此处添加这个数据结构
借助这些数据事件，我们能够获得具体的内存访问信息，而非仅仅恢复寄存器和内存数据。
通过这种基于事件的方法，我们能够有效地构建出一幅详细的崩溃现场“画像”。
这样的信息记录为后续的逆向执行和根因分析提供了数据基础。
这种方法不仅提高了信息记录的效率，而且由于是在控制环境中进行，还增加了分析的可靠性和精确性。
\subsubsection{历史信息指导的逆向执行}
逆向执行阶段的主要目的是构建崩溃测试用例中数据的动态传播路径。
为了解决前文提到的可能会混淆数据流分析的普遍问题——内存别名，本方法采用了一种历史驱动的逆向执行方法。
这种方法通过利用在信息记录阶段捕获的具体内存访问信息，能够有效并准确地解决内存别名问题，从而使得数据依赖关系的追踪更加精确。
这种逆向执行策略增强了对数据传播路径的理解，提高了根因分析的精度和效率。

对于导致崩溃的无效内存访问或无效指令执行，确定根本原因的基本思路是从崩溃处开始逆向执行轨迹中的指令，以查明导致崩溃的数据为何被污染，这个过程被称为逆向执行。
然而，即便拥有完整的执行轨迹，精确地确定数据传播和相关联个别指令也是面临着较大的困难。
这主要是因为内存别名问题。例如，再考虑~\autoref{code_memacc}的例子，其中指令（a）和指令（b）访问相同的内存地址（即$0x201073d4$）。
如果我们能够建立这种关联，那么我们就可以将指令（a）视为崩溃的根本原因。
然而，主要困难在于这些指令涉及的具体内存地址常常由于不可逆指令的存在而变得模糊不清。
以指令$MOV\ R3,\ \#0$为例，它将寄存器$R3$设置为$0x0$，在逆向执行时我们只知道R3在这条指令被执行后的值是$0X0$，但无法恢复这条指令执行前$R3$的原始值。

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{./figure/UD-Chain.png}
    \caption{一个简单的使用定义链示例}
    \label{fig:ud-chain}
\end{figure}

为了应对这一难点，我们设计了一个历史信息指导的逆向执行方法。首先，我们构建使用-定义链来分析执行轨迹，此结构能帮助我们追踪每个操作的影响，明确数据是如何从一个操作传递到另一个操作的。
然后，在使用-定义链的基础上，我们进行了逆向执行指令以恢复寄存器到之前的状态。如~\autoref{fig:ud-chain}是一个简单的使用定义链示例。

\textbf{（1）使用-定义链构建。}\ 这个过程从迭代重构完整执行轨迹开始，
对于遇到的每条指令，我们会仔细解析指令的行为，提取源操作数和目标操作数，这些操作数代表了指令内的数据流。
下面以~\autoref{code:udchain}所示的程序为例展示如何构建使用-定义链：
\begin{lstlisting}[
    language={asm},
    caption={构建使用-定义链过程代码示例},
    label={code:udchain}
]
MOV R1, #4      ; (a) 将数字4加载到寄存器R1
MOV R2, #10     ; (b) 将数字10加载到寄存器R2
ADD R3, R1, R2  ; (c) 将R1和R2的值相加，结果存入R3
STR R3, [R4]    ; (d) 将R3的内容存储到R4指向的内存地址
\end{lstlisting}

首先对于指令(a)：$MOV\ R1,\ \#4$，涉及到的定义节点为$R1$。
对于指令(b)：$MOV\ R2,\ \#10$，涉及到了对$R2$的定义。
对于指令(c)：$ADD\ R3,\ R1, R2$，其中$R1$，$R2$的值被读取并用于计算，因此它们是使用节点；同时这条指令定义了$R3$的值，所以$R3$是一个定义节点。
对于指令(d)：$STR\ R3,\ [R4]$，$R3$的值被用于存储操作，而$R4$是作为地址的基础，因此它们都是使用节点;
同时由于这个操作定义了内存地址$[R4]$的内容，所以$R4$是一个定义节点。
直观的，我们可以用\autoref{fig:viaual_udchain2}如所示来表述数据的流动。
\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{./figure/UD-visual.png}
    \caption{根据\autoref{code:udchain}构建的可视化数据流动方向}
    \label{fig:viaual_udchain2}
\end{figure}
在这个链中，每个箭头代表数据流动的方向，从定义节点到使用节点，然后可能再到另一个定义节点。
根据上述分析，我们可以绘制出一个使用-定义链的简化图，如\autoref{code:viaual_udchain}所示。

\begin{lstlisting}[
    language={asm},
    caption={根据\autoref{code:udchain}构建的可视化使用-定义链},
    label={code:viaual_udchain}
]
(R1) ---> (ADD R3, R1, R2) --> (R3)
(R2) ---> (ADD R3, R1, R2) --> (R3)
(R3) ---> (STR R3, [R4])
(R4) ---> (STR R3, [R4]) ---> [R4]
\end{lstlisting}

通过分析每条新指令的语义，我们可以识别所有相关的源和目标操作数。
同时随着执行轨迹中每条新指令的解析，相应的使用和定义节点被添加到不断增长的使用-定义链中。
通过这种方式，我们可以清晰地追踪程序中各个值的来源和去向，这对于理解程序的行为以及调试和分析程序中的错误非常有帮助。

\textbf{（2）数据恢复。}\ 在构建了使用-定义链后，逆向执行过程的下一步是逆向恢复每条指令执行前的寄存器值。
为了实现这一目标，我们设计了多种处理程序来处理特定类型的指令。
例如，我们为加法操作设计了$add\_handler$函数。
以指令$add R0, R1$为例，我们可以推导出以下三种关系：（1）$R0'=R0+R1$，可以获得$R0'$的值，即指令被执行后$R0$的值；
（2）$R0=R0'-R1$，可以逆向恢复执行前R0的值。
（3）$R1=R0'-R0$，可以逆向恢复R1的值。
如果在三个操作数中只有一个未知值，我们可以使用其他两个值来恢复它，并更新相应的节点。
每当使用-定义链中的一个节点被更新时，本方法会检查整个链条，寻找其他可能的更新来传播。
这个迭代过程持续进行，直到使用-定义链收敛，此时本方法已尽可能多地恢复了之前的状态。

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{./figure/solvealias.png}
    \caption{根据第一阶段记录信息恢复运行时数据示例}
    \label{fig:solvealias}
\end{figure}

值得注意的是，这种方法无法处理内存别名问题。
为了解决这个问题，我们利用第一阶段记录的信息来恢复实际的运行时数据。
例如，对于指令$STR\ R0,\ [R1,\ \#4]$，它将$R0$的值存储在地址$R1+4$的内存中。

如\autoref{fig:solvealias}所示，在之前的足迹收集阶段，我们已经获得了目标地址（即$[R1,\ \#4]$）和要存储的具体数据。
有了这个数据事件，我们可以直接从具体数据中恢复R0的值，并通过从目标地址减去4字节来恢复R1的值。
与假设测试和值集分析等其他技术相比，这种方法不仅保证了精确性，还大大加快了逆向执行的速度。
\subsubsection{根因分析}
在这一节中，我们介绍本文方法的最后一个环节——根因分析。
首先，我们从嵌入式固件崩溃处开始执行后向污点分析，以识别与根本原因相关的指令。
这一分析通过跟踪与崩溃相关的数据的污点传播，来确定可能导致崩溃的指令，
从而使分析人员可以更有效地聚焦于最关键的指令，更精确地定位和理解崩溃的原因。

本阶段主要用到的方法是后向污点分析。后向污点分析从崩溃点开始，逆向追溯数据的来源，以确定是哪些操作和值导致了程序崩溃，从而确定根因。
基于此信息，我们通过逆向执行轨迹，从崩溃点开始追踪数据的反向流动。下面将详细解释后向污点分析环节。

\textbf{（1）污点汇的定义和作用。}\ 
污点汇（Taint Sink）是后向污点分析中定义的一个术语，它指的是分析的起始点，通常是内存地址或寄存器，它们直接关联到错误或异常的发生。
在内存读写错误的情况下，涉及的寄存器或内存位置成为污点汇；
如果是由特定的指令如跳转或调用导致的崩溃，涉及的寄存器（如程序计数器PC）或相关栈地址被标记为污点汇。
如果一条指令试图从一个未初始化的寄存器读取数据或写入到一个非法的内存地址，这个寄存器或内存地址就会被识别为污点汇。

\begin{lstlisting}[
    language={asm},
    caption={污点汇定义示例},
    label={code_taint}
]
xor edi, edi         
mov eax, 1234        
mov [edi], eax      
\end{lstlisting}

在后向污点分析中，我们会寻找与错误直接相关的内存地址或寄存器，这些就是所谓的污点汇。
如~\autoref{code_taint}所示，在这个简单的示例中，$edi$被清零，
而指令$mov\ [edi],\ eax$试图将$eax$寄存器中的值写入到$edi$寄存器指向的内存地址，这会导致访问违规错误。
因此在这个例子，$edi$寄存器是污点汇，
在后向污点分析过程中，我们会从$mov\ [edi],\ eax$开始，追踪导致$edi$被设为零的原因，从而揭示导致程序崩溃的根本原因。

值得注意的是，这个例子中$edi$被简单的清零来模拟非法或被保护的内存地址，
但在更为复杂的程序中，某些寄存器或内存地址可能由于错误的程序逻辑或错误的内存管理而未正确初始化或被错误地修改，从而导致了程序崩溃。

\textbf{（2）后向传播规则。}\ 
本方法中，污点传播规则是用来追踪和分析程序执行过程中数据的流动，尤其是污点汇反向追踪到根因的过程。
这些规则是本方法进行后向污点分析的核心部分，帮助定位和诊断导致程序崩溃或错误行为的具体指令或操作。




\begin{lstlisting}[
    language={python},
    caption={后向污点分析算法},
    label={code_taintcode}
]
Backward_taint_analysis(crash_site, instructions):
    # 1. 利用崩溃发生的指令或位置识别污点汇
    TS = identify_taint_sinks(crash_site)
    # 2. 初始化污点集合
    taint_ins = set(TS)
    # 3. 反向追踪污点
    while taint_ins:
        # 查找当前指令的来源指令，并将其加入污点集合
        for source_ins in find(taint_ins.pop(), instructions):
            taint_ins.add(source_ins)
    # 4. 报告污点分析结果
    report_tainted_instructions(taint_ins)
\end{lstlisting}

~\autoref{code_taintcode}是后向污点分析的伪代码。
本方法中，我们从污点汇出发，使用构建好的使用-定义链追踪数据的来源。下面是污点传播的详细过程：
首先，我们根据使用定义链，识别哪些操作使用了污点汇中的数据，将污点汇转换为使用节点；
之后对于每一个使用节点，我们查找导致这些使用的定义节点，这些定义节点是之前的指令或操作，它们生成或改变了使用节点中的数据；
然后从定义节点开始，我们继续追踪这些节点的使用节点，然后再找到这些使用节点的定义节点。
这个过程是递归进行的，通过不断地追踪定义和使用的关系，
这一过程持续进行，直到没有新的节点可以添加到污点集合中，或者已追溯到数据流的起点。
这意味着所有可能与错误相关的数据流都被标识和分析了；
最后，完成污点传播后，我们集合所有的污点指令，这些指令代表了可能的错误源。通过进一步的分析，可以确定哪些指令最有可能是导致错误的根本原因。

\subsection{整体系统实现}               %3.4节
本工作伪代码如~\autoref{alg:code}所示。
\begin{table}[h]
    \centering
    \caption{物联网嵌入式固件自动化根因分析方法伪代码}
    \label{alg:code}
    \begin{tabular}{p{\linewidth}}
        \toprule
        \textbf{Algorithm}: RootCauseAnalysisOfFirmware \\
        \midrule
        \textbf{Input}: Crashing Testcase, Firmware \\
        \textbf{Output}:Root Cause Analysis Report
        \begin{algorithmic}[1]
        \Function{RCA\_F}{}
        \State $RuntimeData\ \gets\ InfoRecord(Crashing Testcase,\ Firmware)$
        \State $UD\_Chain\ \gets\ ReverseExecute$
        \State $Tainted\_ins\ \gets\ BackwardTainted(RuntimeData, UD\_Chain)$
        \State $Root\ Cause\ Analysis\ Report\ \gets\ Analysis\ and\ Report(Tainted\_ins)$
        \State \textbf{return} $Root\ Cause\ Analysis\ Report$
        \EndFunction
        \end{algorithmic} 
        \bottomrule
    \end{tabular}
\end{table}
首先，本方法接受固件二进制程序和崩溃测试用例作为输入，并以崩溃测试用例作为输入仿真执行固件二进制程序，以重现崩溃现象。
在执行过程中，通过监控内存访问和执行轨迹，收集包括具体的内存读写操作和执行的指令地址等的运行时数据；
之后进行逆向执行过程，根据收集到的数据，构建使用-定义链，用于追踪程序中的数据流和依赖关系。
同时通过逆向追踪程序执行，以识别和解析内存别名问题，精确跟踪数据依赖。
然后进行根因分析阶段，从崩溃点开始，进行后向污点分析。通过反向分析数据的流动标识和跟踪污点数据，分析可能导致崩溃的操作和指令，以确定导致崩溃的根本原因。
最后整理结果，输出详细的分析报告，包括可能的崩溃原因、关键的污点指令等。



\subsection{本章小结}                   %3.5节
在本章中，我们概述了物联网嵌入式固件在现代技术领域中的重要性和由于安全缺陷带来的风险，并对本文主要方法设计进行了阐述。
首先我们定义了本文关注的主要问题，即无效的内存访问和无效的指令执行的问题，同时也说明了需要特别解决的内存别名问题。
之后介绍了本方法的三个主要的组件实现：高效运行时信息记录、历史信息指导的逆向执行和后向污点分析。
在高效运行时信息记录阶段，我们通过模拟执行引起崩溃的测试用例来收集关键的运行时数据。
在历史信息指导的逆向执行阶段，我们利用已收集的具体内存访问信息解决内存别名问题，确保数据流分析的准确性。
在根因分析阶段，我们通过后向污点分析确定导致崩溃的具体原因，为进一步的调查提供指导。
最后展示了我们提出的物联网嵌入式固件自动化根因分析方法的伪代码并对整个流程进行整合性说明。





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%第4章 实验与评估%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\section{实验与评估}        %第4章
\subsection{实验环境}
本项工作的实验部分是在一台：
（1）处理器为56核Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GHz
（2）操作系统为Ubuntu 22.04.2 LTS
（3）内存为252GB的机器上完成的。
\subsection{实验方案}
\subsubsection{实验测试样例}
为了测试本文提出的物联网嵌入式固件自动化根因分析方法进行全面评并估，
我们使用了Fuzzware~\cite{Fuzzware}框架提供的公共数据集。
\begin{table}[h]\tiny
    \caption{本实验用到的41个测试样例的信息}
    \label{exp-0}
    \centering
    \begin{tabular}{@{}ccc|ccc@{}}\toprule
    序号 & 硬件平台 & 固件样例 & 序号 & 硬件平台 & 固件样例 \\ \midrule
    $T_1$ & ARCH\_PRO & Pw\_Discovery & $T_{22}$ & MAX32600 & RF\_Door\_Lock \\
    $T_2$ & EFM32GG\_STK3700 & Pw\_Discovery & $T_{23}$ & SAMR21 & 6LoWPAN\_Receiver \\
    $T_3$ & EFM32LG\_STK3600 & Pw\_Discovery & $T_{24}$ & SAMR21 & 6LoWPAN\_Sender \\
    $T_4$ & LPC1549 & Pw\_Discovery & $T_{25}$ & MAX32600 & RF\_Door\_Lock \\
    $T_5$ & LPC1768 & Pw\_Discovery & $T_{26}$ & STM32F103RE & 3DPrinter \\
    $T_6$ & MOTE\_L152RC & Pw\_Discovery & $T_{27}$ & STM32F429ZI & utasker\_MODBUS \\
    $T_7$ & NUCLEO\_F103RB & Pw\_Discovery & $T_{28}$ & STM32F429ZI & utasker\_MODBUS \\
    $T_8$ & NUCLEO\_L152RE & Pw\_Discovery & $T_{29}$ & STM32L432KC & Zepyhr\_SocketCan \\
    $T_9$ & UBLOX\_C027 & Pw\_Discovery & $T_{30}$ & STM32L432KC & Zepyhr\_SocketCan \\
    $T_{10}$ & STM32F429ZI & CNC & $T_{31}$ & STM32F429ZI & utasker\_USB \\
    $T_{11}$ & STM32F103RB & Gateway & $T_{32}$ & SAM4E\_XPRO & Socket\_Echo\_Server \\
    $T_{12}$ & STM32F429ZI & PLC & $T_{33}$ & DISCO\_L475\_IOT1 & Bluetooth\_Peripheral\_HIDs \\
    $T_{13}$ & STM32F429ZI & PLC & $T_{34}$ & DISCO\_L475\_IOT1 & Bluetooth\_Peripheral\_HIDs \\
    $T_{14}$ & STM32F103RB & Robot & $T_{35}$ & SAM4S\_XPLAINED & Socket\_Echo\_Server \\
    $T_{15}$ & STM32F103RB & Gateway & $T_{36}$ & SAM4S\_XPLAINED & Socket\_Echo\_Server \\
    $T_{16}$ & STM32F103RB & Gateway & $T_{37}$ & NRF52840 & Bluetooth\_Peripheral\_HIDs \\
    $T_{17}$ & STM32F103RB & Gateway & $T_{38}$ & SAM4S\_XPLAINED & Bluetooth\_Peripheral\_HIDs \\
    $T_{18}$ & STM32F103RB & Gateway & $T_{39}$ & CC2538 & hello-world \\
    $T_{19}$ & STM32F429ZI & PLC & $T_{40}$ & CC2538 & snmp-server \\
    $T_{20}$ & STM32F429ZI & utasker\_USB & $T_{41}$ & CC2538 & hello-world \\
    $T_{21}$ & MAX32600 & Thermostat &  &  &  \\
    \bottomrule
    \end{tabular}
\end{table}
Fuzzware是一种专门针对嵌入式固件进行模糊测试的框架。
该数据集包含61个测试样例，其中涵盖了包括各种漏洞的固件。
其中每个测试样例包括原始的二进制固件、基本配置文件、导致其崩溃的输入和崩溃描述。
按照Fuzzware的官方指导，我们在其重现模式下部署框架，并成功重现了41个展示崩溃行为的测试用例，如~\autoref{exp-0}所示，本实验对象即为这41个测试样例。
要对本文方法进行测试，首先需要明确这41个测试样例崩溃的根本原因。
我们尝试根据其提供的崩溃描述中识别出根本原因，然后对于那些缺乏明确描述的测试套件，我们手动检查其固件映像的汇编代码并利用执行日志来识别根本原因。
\subsubsection{实验评估办法与关注的问题}
为了进行全面评并估本文提出的方法，我们从根因分析能力，根因分析的开销以及信息记录组件效率等方面进行实验。为此我们提出了三个研究问题：

\textbf{根因分析的能力如何？}\ 
为了确定本方法是否能用于找到导致固件程序发生崩溃的根本原因，本文在41个测试样例上应用了本方法。
对于我们给出的可疑根因分析报告，如果真实根因在此列表较为靠前的位置，则可以认为是发现了根因，且此名次越小，时间开销越低。

\textbf{根因分析的开销是否可以接受？}\ 
根因方法的开销指的是本方法中各个步骤所需的时间。
由于信息记录组件是本文核心设计之一，将于实验第三部分进行更完善的综合分析。
本部分就逆向执行、根因分析两个环节的时间开销进行统计，衡量根因分析的开销。


\textbf{运行时信息记录组件是否足够高效？}\ 
特别的，高效运行时信息记录组件是本文的核心设计之一，由于嵌入式固件运行时资源受限，过多的运行时信息记录可能会有较大的时间和空间开销。
因此就本设计的资源占用开销进行分析，检测其是否足够高效。
\subsection{实验结果与分析}
\subsubsection{根因分析能力}
为了确定本方法进行物联网嵌入式固件根因分析的能力，本文在41个测试样例上应用了本方法，并且定义：
对于一个测试样例来说，如果导致它崩溃的真实根因在我们给出的可疑根因报告的靠前位置（前5名），我们认为本方法找到了根因。
为模拟实际根因分析中可容忍的时间限定，我们给定了24小时的时间作为分析阈值。
篇幅所限，我们选择了根因的测试样例进行展示，本部分实验的结果如~\autoref{exp-1}所示。

\begin{table}[ht]
    \caption{根因分析能力}
    \label{exp-1}
    \centering
    \begin{tabular}{@{}cllc@{}}\toprule
    序号 & 硬件平台 & 固件样例 & 排名 \\ \midrule
    $T_{16}$ & STM32F103RB & Gateway & \text{top 1} \\
    $T_{26}$ & STM32F103RE & 3DPrinter & \text{top 1} \\
    $T_{30}$ & STM32L432KC & Zepyhr\_SocketCan & \text{top 1} \\
    $T_{38}$ & SAM4S\_XPLAINED & Bluetooth\_Peripheral\_HIDs & \text{top 1} \\
    $T_{40}$ & CC2538 & snmp-server & \text{top 3} \\
    \bottomrule
    \end{tabular}
\end{table}

表中的排名项表示真实根因在我们给出报告中的排名。
结果显示，本方法成功发现了5个测试样例的根因，且均位于我们报告的可疑指令中的前3名，且其中4个位于第1名。
实验结果证明了本方法对具有自动化分析的能力。
虽然成功率为12.19\%，但考虑到这是首个针对物联网嵌入式固件进行自动化根因分析的方法，认为本方法的根因分析较好。

对于其余未被分析出来的测试样例，我们选取了其中部分样例进行人工分析后，将其归结为根本原因过深的原因，并将在下一节中进行详细说明。


\subsubsection{根因分析的开销}
\textbf{总时间开销。}\ 本方法在给定的时间阈值内，能较为有效地进行固件自动化根因分析。
但在进行根因分析能力时，我们发现部分样例无法识别或超时，我们猜想是由于需要分析的指令数过长的原因。
对于这些样例来说，根因过度远离崩溃现场，导致执行轨迹较长，目前的运行时信息记录方法存在一定的不足，使分析复杂化。
\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth]{./figure/sns_4_exp_total_time.png}
    \caption{分析的指令长度对时间开销的影响}
    \label{exp-4}
\end{figure}

因此为了更全面地展示本方法的时间开销，本部分对指令长度对根因分析时间开销影响进行了测试与分析。
如~\autoref{exp-4}所示，我们随机选择5个崩溃测试用例，随着分析深度的线性增加，所消耗的时间随之指数级增长。
这突出随着根因深度的过大，问题的复杂度会显著提高，已有的信息记录的不足被不断放大直到难以解决。

\textbf{根因分析各个组件的时间开销。}\ 分析了总时间开销后，本部分将就逆向执行、后向污点分析两个环节的时间开销进行统计，衡量他们在根因分析的开销占比。
\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{./figure/sns_2_exp_resolve_time_backward_tainting_time.png}
    \caption{逆向执行阶段的时间开销}
    \label{exp-2}
\end{figure}
由于前面实验已验证分析过深指令会导致本方法超时，因此本部分实验仅仅分析每个测试样例的后3000条指令，并记录逆向执行的时间。
实验结果如~\autoref{exp-2}所示。

首先是衡量逆向执行的时间，逆向执行阶段平均花费了1025秒。同时，检查本方法可以发现根因的五个样例，我们可以发现他们的逆向执行耗时较短。
间接印证了对于本方法无法分析出根因的情况，是由于样例的指令过长导致超时。
由于图中其他样例分析时间并未超出这5个样例很多，
所以我们有理由可以设想，如果放宽对时间的限制，将时间上限延长到两周甚至一个月，可能本方法能分析出绝大多数样例的根因。
值得注意的是，综合前面的分析逆向执行占据了大部分的时间成本，虽然时间在可接受范围内，但此阶段在后续研究应当被重点关注。

之后是后向污点分析的时间分析，由结果可以看出，后向污点分析时间时间开销很短，几乎可以忽略不计。


\subsubsection{信息记录组件效率}
由于运行时信息记录组件关注内存的读取和写入操作，如内存访问，寄存器操作等，本方法利用固件重置技术来执行崩溃测试用例，同时监控和记录内存读写。
由于内存读取和写入操作在指令中占比较高，所以可能会有较多的信息被记录，本组件的效率需要被验证。
因此本部分实验重点检验运行时信息记录组件，检测其是否足够高效。
为了测量这种基于事件的方法的开销，我们将本方法能找到根因的样例重复测试50次。
结果如~\autoref{exp-5}所示。
\begin{table}[ht]
    \centering
    \caption{信息记录组件效率分析}
    \begin{tabular}{@{}clcc@{}}
        \toprule
        \multicolumn{1}{l}{}      &            & 不进行信息记录 & 进行信息记录 \\ \midrule
        \multirow{2}{*}{时间开销(s)} & 平均值    & 0.82      & 3.23        \\ \cmidrule(l){2-4} 
                          & 倍率 &  -       & 3.94$\times{}$   \\ \midrule
        空间开销 (MB)                & 平均值    & 0         & 7.65        \\ \bottomrule
    \end{tabular}
    \label{exp-5}
\end{table}

实验结果显示，高效信息记录组件的平均耗时为3.23秒，是不进行信息记录的3.94倍；
而所生成的记录文件平均大小为7.65MB。
结果表明，虽然接近4倍的运行时间值得被考虑，但是考虑到执行的总时间并没有过大，所以信息记录组件时间开销非常优秀。
同样，对于固件代码大小来讲，所占用的空间也可以接受，不会造成负面影响。
究其原因，在于本信息记录方法只在特定的事件发生时才触发数据记录，
例如，在执行轨迹和内存访问时，只有在特定条件触发时（如特定的内存读写操作或关键代码执行点）才会记录相关数据。
这种选择性记录大大减少了需要处理和存储的数据量，从而降低了开销。
综上所述，在极大提高了固件根因分析能力的情况下，信息记录组件的额外开销可以接受，足够高效。
\subsection{本章小结}
本章中，我们首先介绍了实验环境以及实验所用的测试样例，并分析了实验评估办法与实验所关注的三个问题。
之后从根因分析能力，根因分析的开销以及信息记录组件效率三个角度对本文提出的物联网嵌入式固件自动化根因分析方法进行评估。
实验结果显示，该方法能够较好地解决物联网嵌入式固件难以进行自动化根因分析的问题，并能较高效地发现导致崩溃的根本原因，且不会引入较高的空间开销。
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%第5章 总结与展望%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\section{总结与展望}        %第5章
\subsection{研究工作总结}
本文对物联网嵌入式固件安全性问题进行研究，通过对嵌入式固件的特点与根因分析难点进行归纳与研究，
提出了针对物联网嵌入式固件的自动化根因分析方法。本文主要工作总结如下：

\textbf{提出了针对物联网嵌入式固件的自动化根因分析方法。}\ 我们设计了一个针对固件特点进行自动化根因分析的方法，
通过高效收集运行时信息，逆向执行与后向污点分析
支持对低资源固件模糊测试后的根因分析工作，填补了这一领域的空白。
经过实验测试，可以较为良好且高效地完成自动化根因分析工作。

\textbf{提出了一种高效的运行时信息记录方法。}\ 基于事后的工作普遍认为记录运行时数据会引入巨大的时间开销。
因此，它们依赖于核心转储、执行轨迹和崩溃现场的内存快照来推断内存别名。
推断数据和实际数据之间的差异阻碍了反向执行和向后污点分析的性能。
而这种方法对于调试信息被剥离的固件来讲更加难以推断与分析。
本文提出的信息记录方法仅针对内存读写操作，只在特定的事件发生时才触发数据记录，这种选择性记录大大减少了需要处理和存储的数据量，从而降低了开销，
并为后续分析提供了必要的历史信息，可以很好地解决内存别名问题。


\subsection{研究工作展望}
本文的核心贡献是提出了针对物联网嵌入式固件的自动化根因分析方法，填补了这一领域的空白。
然而本文还有很多可以改进的地方，存在一些没有解决的问题。


\textbf{优化逆向执行阶段。}\ 如~\autoref{exp-2}所示，逆向执行占用了较多时间，在后续优化工作中应当被重点关注。
同时对于其他逆向执行阶段花费时间较短但本方法并未分析出根因的样例，说明并非由于根因过深导致难以分析，
本方法在其他方面仍然有可优化之处。

\textbf{与模糊测试结合形成整体测试平台。}\ 尽管本文的方法并非专门为数据集设计，
本方法依赖现成的基于已有的固件fuzzer（Fuzzware）来复现崩溃和收集运行时信息，
而固件fuzzer的能力限制了可以有效测试的固件和平台的范围，因此本方法可能不适用于所有类型的嵌入式固件。
未来可以尝试与不同的模糊测试工具进行结合，提高本方法的可拓展性。


\textbf{与大语言模型结合。}\ 限制物联网嵌入式固件根因分析的一项重要特点是其被剥离了调试代码。
虽然依赖于现成的固件模糊器，我们可以收集必要的运行时信息，但对整个程序意图的有限理解依然会对分析造成较大的障碍。
随着大语言模型的飞速发展，未来可以将本方法与大型语言模型等先进技术相结合，
一方面可以辅助理解固件代码的语义，另一方面，无论在进行模糊测试崩溃描述还是在进行根因分析结果汇报时，
都可以生成更全面、更自然的语言描述，以确定根本原因。
