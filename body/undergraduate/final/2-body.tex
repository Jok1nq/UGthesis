% \cleardoublepage

% \section{Overleaf 使用注意事项}

% 如果你在Overleaf上编译本模板，请注意如下事项~\cite{zjuthesis}：

% \begin{itemize}
%     \item 删除根目录的 ``.latexmkrc'' 文件，否则编译失败且不报任何错误
%     \item 字体有版权所以本模板不能附带字体，请务必手动上传字体文件，并在各个专业模板下手动指定字体。
%         具体方法参照 GitHub 主页的说明。
%     \item 当前（2019年9月2日）的Overleaf使用TexLive 2017进行编译，但一些伪粗体复制乱码的问题需要TexLive 2019版本来解决。
%         所以各位同学可以在Overleaf上编写论文，但务必使用本地的TexLive 2019来进行最终编译，以免产生查重相关问题。
%         具体说明参照 GitHub 主页。
% \end{itemize}

% \subsection{节标题}

% \subsubsection{小节标题}   %2.1

% \par 我们可以用includegraphics来插入现有的jpg等格式的图片，如\autoref{fig:zju-logo}。

% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=.4\linewidth]{logo/zju}
%     \caption{\label{fig:zju-logo}浙江大学LOGO}
% \end{figure}

% \par 如\autoref{tab:sample}所示，这是一张自动调节列宽的表格。

% \begin{table}[ht]
%     \caption{\label{tab:sample}自动调节列宽的表格}
%     \begin{tabularx}{\linewidth}{|c|X<{\centering}|}
%         \hline
%         第一列 & 第二列 \\ \hline
%         xxx & xxx \\ \hline
%         xxx & xxx \\ \hline
%         xxx & xxx \\ \hline
%     \end{tabularx}
% \end{table}

% \par 如\autoref{equ:sample}，这是一个公式

% \begin{equation}
%     \label{equ:sample}
%     A=\overbrace{(a+b+c)+\underbrace{i(d+e+f)}_{\text{虚数}}}^{\text{复数}}
% \end{equation}

% \par 如\autoref{code:sample}所示，这是一段代码。
% 计算机学院的代码样式可能与其他专业不同，
% 如有需要，可以从计算机学院专业模板中复制相关的代码样式设定。

% \begin{lstlisting}[%
%     language={C},
%     caption={simple.c},
%     label={code:sample}
% ]
% #include <stdio.h>

% int main(int argc, char *argv[])
% {
%     printf("Hello, zjuthesis\n");
%     return 0;
% }
% \end{lstlisting}





% \subsection{关于字体}      %2.2

% 英文字体通常提供了粗体和斜体的组合，中文字体通常没有粗体或斜体，本模板使用了 `AutoFakeBold' 来实现中文伪粗体，但不提供中文斜体，如\autoref{tab:font-examples}所示。

% \begin{table}
%     \centering
%     \caption{一些字体示例}
%     \label{tab:font-examples}
%     \begin{tabular}{|c|c|c|c|c|}
%         \hline
%         字体            & 常规             & 粗体                       & 斜体                      & 粗斜体                                \\ \hline
%         Times New Roman & Regular         & {\bfseries          Bold} & {\itshape         Italic} & {\bfseries \itshape      BoldItalic} \\ \hline
%         仿宋            & {\fangsong 常规} & {\fangsong \bfseries 粗体} & {\fangsong \itshape 斜体} & {\fangsong \bfseries \itshape 粗斜体} \\ \hline
%         宋体            & {\songti   常规} & {\songti   \bfseries 粗体} & {\songti   \itshape 斜体} & {\songti   \bfseries \itshape 粗斜体} \\ \hline
%         黑体            & {\heiti    常规} & {\heiti    \bfseries 粗体} & {\heiti    \itshape 斜体} & {\heiti    \bfseries \itshape 粗斜体} \\ \hline
%         楷体            & {\kaishu   常规} & {\kaishu   \bfseries 粗体} & {\kaishu   \itshape 斜体} & {\kaishu   \bfseries \itshape 粗斜体} \\ \hline
%     \end{tabular}
% \end{table}

% \sectionnonum[none]{同一页上的章标题}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%第2章 自动化根因分析相关技术研究%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{自动化根因分析相关技术研究}
\subsection{概述}
在科学和工程学中，根因分析是一种解决问题的方法，用于识别故障或问题的根本原因。
它广泛应用于IT运营、电信、工业过程控制、事故分析、医学等。
根因分析通常是一种系统性的过程，需要收集和分析与问题相关的数据和信息，运用各种工具和技术来确定问题的根本原因。
在计算机领域，特别是在软件安全领域，根因分析通常是指分析软件或系统崩溃的根本原因，它可能涉及对系统的代码、设计、配置、环境等方面进行深入分析。
通过根因分析，开发团队可以更好地了解程序中的潜在问题，并及时采取措施修复和加固系统，以提高软件的安全性和稳定性。
作为一种粗略的可靠性度量方法，模糊测试可以针对待分析程序产生不同输入得到程序崩溃，并提示程序哪些部件需要特殊的注意；
而根因分析作为模糊模糊测试的后续阶段，可以利用，模糊测试得到的已知崩溃进行深入分析并找出导致这些问题的根本原因。
%此处要插入一个自动化根因分析方法的概述图
一般来说，当前自动化根因分析方法主要包括两类:基于频谱的根因分析方法和基于事后的根因分析方法。
其中基于频谱的方法通常在初始崩溃测试用例的基础上生成两大组崩溃测试用例和非崩溃测试用例。
它们记录每条指令上的寄存器和内存数据，以统计方式构建崩溃的必要条件作为谓词，测量每个谓词与初始崩溃的相关性，最后将谓词列为根本原因；
而基于事后的故障定位方法从调试文件(例如核心转储和内存快照)开始，执行反向执行和向后污染分析，以跟踪无效数据的传播。
它们分析指令的语义，比基于频谱的故障定位方法更有效。
同时，随着当前AI领域的发展，机器学习的长足发展与大模型的出现使根因分析进入了新的维度，一些繁杂的人工工作可以交由AI辅助进行。
这极大提高了一些受到时间和复杂程度限制方法的效率，拓宽了根因分析领域

下面将从这三个方面介绍自动化根因分析相关技术的研究
\subsection{自动化根因分析相关方法}
%下面三个要分别插入一个类别的论文的方法图
\subsubsection{基于频谱的自动化根因分析方法}
基于频谱的分析方法是一种利用软件系统的执行频谱（Execution Spectrum）来识别和定位问题的技术。
该方法通常用于识别性能问题和资源利用不足等情况。
基本原理是在软件运行时记录系统的执行轨迹或事件，然后通过分析这些事件的频率和模式来识别可能的瓶颈或问题。
基于频谱的故障定位技术基于一个核心假设：程序中出错频率较高的部分更有可能是故障所在。
这种方法使用“频谱”信息，即程序执行过程中各个组件（如函数、语句或分支）的执行频率和失败频率的统计数据。
例如，对于性能问题，可以记录系统中的函数调用、代码路径执行次数、资源利用情况等信息。
通过分析这些数据，可以确定哪些函数或路径是性能瓶颈，并识别可能的优化方向。
这种方法可以帮助开发人员了解系统的执行特征，并优化系统的性能和资源利用率。
大多数基于频谱的根因分析技术研究侧重于统计量的设计，包括排名指标和分布统计。
但也有一些工作侧重对测试用例的研究：
Hao等人~\cite{Test2010}根据测试用例的能力提出了三种减少测试用例数量的策略,基于使用测试输入的测试运行的执行跟踪，使开发人员可以只选择测试输入的一个有代表性的子集来进行结果检查和故障定位；
Abreu等人~\cite{practical2009}通过使用由西门子集和空间程序组成的通用基准，研究了作为多个参数（例如系统执行期间收集的程序频谱的质量和数量）的函数的诊断准确性，结果表明用于分析程序谱的特定相似系数的优越性能在很大程度上独立于测试设计，并且证明了SFL可以有效地应用于工业环境中的嵌入式软件开发环境中；
Dandan Xu等人~\cite{Racing}设计并实现了一种反例强化学习技术，该技术奖励涉及反例的操作，通过平衡随机抽样和对反例的利用，利用每个模糊测试回合的结果来指导下一轮模糊测试，从而将当今基于频谱的根因分析工具的可扩展性和准确性提高了一个数量级以上。

\subsubsection{基于事后的故障定位方法}
基于事后的根因分析技术是一种在崩溃发生后开始的根因分析技术。
该方法的基本原理是通过收集和分析系统状态、日志、内存转储等信息，来确定问题的根本原因和触发条件。
通过分析这些信息，可以确定程序的内存泄漏、空指针引用等异常行为，并采取措施修复或预防类似问题的再次发生。
在事后程序分析技术中，记录与重放~\cite{ReCrash2008}~\cite{SymCrash2014}~\cite{Chronicler2013}和核心转储分析~\cite{RETracer2016}~\cite{Making2015}~\cite{CREDAL2016}是两种常见方法。

\textbf{记录与重放}\ 这种方法的核心思想是在程序运行时使用工具捕获程序的执行轨迹和状态，从而允许开发者在出现故障时能够准确重现问题。
在程序执行过程中，记录所有导致状态变化的事件，包括函数调用、外部输入、线程操作和其他系统调用等事件。
之后利用捕获的这些事件的参数和结果，以及它们的时间戳和执行顺序进行事后分析，找到导致崩溃的根因。
值得注意的是通常“记录”过程需要通过修改操作系统的内核、使用特定的库或工具、或者插桩代码来实现；同时“重放”过程通常需要在一个控制的环境中进行，以避免非确定性行为的干扰。
这种方法存在着局限性：（1）记录阶段可能会引入显著的时间和空间开销，特别是在需要详尽记录的情况下。
（2）无法重放某些不确定性较高的行为：如并发和竞争条件漏洞导致的崩溃就可能在重放时难以精确复现。

\textbf{核心转储分析}\ 与记录与重放方法不同，核心转储分析方法涉及捕捉程序崩溃时的内存镜像，以便分析和诊断导致崩溃的原因。
这种技术对于理解复杂软件系统的失败原因非常有用，特别是在调试难以复现的故障时体现出了较大的优势。
核心转储方法的基本原理是当程序异常终止（如段错误）发生崩溃时，自动保存那部分程序执行时的内存内容。
这个转储文件包含了程序终止时的变量值、程序计数器、寄存器内容、堆栈信息等关键数据。
发生崩溃后，分析者通过检查崩溃时的内存状态，分析崩溃的上下文，确定崩溃发生在程序的哪一部分。
这种方法存在着一定的局限性：（1）核心转储文件可能非常大，尤其是密集应用内存的程序，这可能极大提高分析的开销。
（2）某些崩溃依赖于程序运行的特定环境或状态，单纯利用核心转储文件无法分析导致崩溃的原因。


虽然当前这些研究被证明是有效的，但它们只关注特定的类型状态问题，或者在反向执行时难以解决内存别名等问题，仍然不足够高效。
\subsubsection{基于机器学习的自动化根因分析方法}
这种方法利用机器学习算法来自动识别和诊断系统故障的根本原因，并依赖于历史数据和模式识别技术来预测和识别问题的根源。这种方法在处理复杂系统和大规模数据时显示出其独特的优势。
通过分析系统的正常运行数据和故障时的数据，机器学习模型可以学习到哪些指标或事件与系统故障强相关。
在基于机器学习的自动化根因分析方法中，首先收集系统的运行日志、性能指标、系统事件等数据；
其次从原始数据中提取有用的特征如CPU使用率、内存使用量、响应时间、错误率等，这些特征能够代表系统的运行状态或可能影响系统性能和稳定性的因素；
之后利用其训练机器学习模型，并在实际数据上运行模型，以检测和预测潜在的系统故障。
这种方法也存在着一定的局限性：（1）模型的效果很大程度上依赖于高质量和高覆盖率的数据，需要人工提供较为优质的训练数据。（2）模型需要不断维护、微调与更新，从而能在快速变化的系统环境中适应新的数据和条件。
图n展示了ModelCoder~\cite{9521318}这一基于机器学习的自动化根因分析方法的实现过程：

\subsection{其他相关研究}
\subsubsection{逆向执行}
在基于事后分析的故障定位领域，分析人员通过反向执行来更深入地了解程序崩溃~\cite{RETracer2016}~\cite{REPT}。
反向执行是一种通过撤销已执行的指令,恢复寄存器和内存值到先前状态的技术，使分析人员能够从独特的视角观察程序状态随时间的演变过程。
这需要分析人员设计复杂的处理器，根据指令的行为逆向执行指令。
在本文关注的嵌入式固件领域，目标硬件平台的资源受限性质通常严重限制了监控和记录能力，导致无法获取足够的数据以支持全面的反向执行。
为了解决这一问题，需要设计合理的运行时记录方法，并为嵌入式固件设计合适的逆向处理器。

\subsubsection{使用——定义链}
在数据流分析领域，使用——定义链(Use-Define Chain)是一种描述程序中一个变量的使用和所有定义的数据结构，该变量可以在没有任何其他中间定义的情况下到达使用~\cite{Compilers2007}。
使用定义链建立了程序中变量的定义点（定义变量值的地方）与使用点（使用这些变量值的地方）之间的关系。
通过这种结构，分析人员可以追踪变量值是如何在程序中传递和转换的，从而可以提高逆向执行中的效率

\subsection{本章小结}
本章中，首先对根因分析方法进行了简单背景介绍，然后讨论了当前主流的几种自动化根因分析方法，并分析了他们的优势与不足。
最后补充分析了自动化根因分析方法中逆向执行和使用——定义链等其他相关研究。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%第3章 物联网嵌入式固件自动化根因分析%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{物联网嵌入式固件自动化根因分析}
\subsection{引言}
随着网络技术的飞速发展，物联网技术的应用已经渗透到各个产业领域。
嵌入式固件在这些领域中起着关键作用，它使得设备和系统能够实现自动化、智能化的控制和管理，提高生产效率、节约资源、降低成本。
然而随着嵌入式固件深入生活各个领域，其中的漏洞与安全问题重要性愈发重要。
2023年12月，丰田雷克萨斯~\cite{toyota}由于发动机电子控制单元存在安全隐患，召回了超过十万辆车。
嵌入式固件安全在国防方面同样重要，俄乌战争中，Viasat的KA-SAT网络收到了攻击~\cite{KASAT}，
攻击者利用卫星调制解调器固件的漏洞进行攻击，导致KA-SAT的卫星宽带服务部分中断，影响了数千名客户和5800台风力涡轮机的远程访问。

目前模糊测试领域已有较为成熟的方法来检测固件漏洞，但在模糊测试发生崩溃后，需要进一步进行根因分析导致崩溃的原因，修复漏洞。
目前已有几种主流的自动化根因分析方法。
但目前尚未有针对嵌入式固件的自动化根因分析方法。由于嵌入式固件运行时资源受限，以及代码缺乏必要的调试信息，导致在固件领域已有的自动化分根因析方法难以有效分析导致崩溃的根本原因；
而手动分析较为繁琐，且由于人工难以理解二进制固件代码，难以全面分析，并高覆盖率发现bug。

综上所述，如何针对物联网嵌入式固件实现高效自动化根因分析方法，发现固件漏洞，保障物联网嵌入固件安全，是当前亟需解决的问题。

\subsection{问题定义}
\subsubsection{本文关注的根本原因}
现实世界中的固件崩溃原因多种多样且复杂，如使用后释放（use after free）、双重释放（double free）和越界写入（out-of-bounds write）。
然而，大多数导致固件崩溃的原因有两个：无效的内存访问和无效的指令执行。
它们直接关系到程序的基本执行和内存管理机制。
这些问题是所有计算系统都必须妥善处理的基本安全和稳定性挑战，解决这类漏洞是提高固件质量和系统安全的关键。

\textbf{无效的内存访问}\ 无效的内存访问包括越界访问（程序试图访问数组、字符串或其他数据结构的边界之外的内存）、野指针访问（未初始化或已释放的指针被错误地用于内存访问）、
空指针解引用（程序试图通过一个指向NULL的指针访问内存）以及访问已经被释放的内存块。
这些无效内存访问会触发操作系统的保护机制，如分页错误（page fault）或访问违规（access violation），从而导致程序崩溃或终止。
同时也可能导致数据损坏或被恶意代码利用。

\textbf{无效的指令执行}\ 无效的指令执行通常指的是程序试图执行非法或非预期的机器指令，



\subsection{物联网嵌入式固件自动化根因分析方法设计}
\subsection{整体系统实现}
\subsection{本章小结}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%第4章 实验与评估%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{实验与评估}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%第5章 总结与展望%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{总结与展望}
